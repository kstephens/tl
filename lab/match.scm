(define (match-expr val cases)
  (define (match-cases val cases f)
    (let ((val-name (gensym 'match-val)))
      `(let ((,val-name ,val))
         ,(match-cases-list val-name cases f))))
  (define (match-cases-list val cases f)
    (if (null? cases) f
      (match-case val (car cases)
        (match-cases-list val (cdr cases) f))))
  (define (match-case val case f)
    (if (not (pair? case)) (error "case not a pair." case))
    (match-datum (car case) val `(begin ,@(cdr case)) f))
  (define (match-datum pat val t f)
    (if (quasiquote? pat)
      (match-sequence (cadr pat) val t f)
      (match-item pat val t f)))
  (define (match-sequence pat val t f)
    (if (null? pat) (match-item pat val t f)
      (if (and (pair? pat) (unquote-splicing? (car pat)))
        (match-var (cadr (car pat)) val t f)
        (let ( (car-val (gensym 'car-))
               (cdr-val (gensym 'cdr-)))
          `(if
             (pair? ,val)
             (let ( (,car-val (car ,val))
                    (,cdr-val (cdr ,val))
                    )
               ,(match-item (car pat) car-val
                  (match-sequence (cdr pat) cdr-val t f) f)) 
             #f)))))
  (define (match-item pat val t f)
    (cond
      ((unquote? pat) (match-var      (cadr pat)   val t f))
      ((pair? pat)    (match-sequence pat          val t f))
      (else           (match-atom     (quote! pat) val t f))))
  (define (match-var var val t f)
    `(let ((,var ,val))
       ,t))
  (define (match-atom pat val t f)
    (if (and (eq? t #t) (eq? f #f))
      `(equal? ,pat ,val)
      `(if (equal? ,pat ,val)
         ,t ,f)))
  (define (quote! x)
    (list 'quote x))
  (define (unquote? pat)
    (and 
      (pair? pat)
      (eq? 'unquote (car pat))
      (pair? (cdr pat))
      (symbol? (cadr pat))))
  (define (unquote-splicing? pat)
      (and 
        (pair? pat)
        (eq? 'unquote-splicing (car pat))
        (pair? (cdr pat))
        (symbol? (cadr pat))))
  (define (quasiquote? pat)
    (and 
      (pair? pat)
      (eq? 'quasiquote (car pat))))

#|   
  (define (test f pat)
    (newline)
    (write (list 'match pat 'val))(newline)
    (display " => ")(newline)
    (write (f pat 'val '(list :matched! :a a) :NOT-matched!))(newline)) 
  (test match-datum 'a)
  (test match-datum ',a)
  (test match-datum '())
  (test match-datum '(1))
  
  (test match-datum '`())
  (test match-datum '`())
  (test match-datum '`(1))
  
  (test match-datum '`(,a))
  (test match-datum '`(,@rest))
  (test match-datum '`(1 ,@rest))
  (test match-datum '`(1 a 3))
  (test match-datum '`(1 ,a 3))
|#
  (match-cases val cases #t)
)
#|
(let ()
  (define (test val . cases)
    (newline)
    (write `(match-expr ,val ,cases))(newline)
    (display " => ")(newline)
    (write (match-expr val cases))(newline))
  (display "calling match-expr...")(newline)
  (test 'x
    '(`(fx+ ,a ,b) `(let ((reg1 ,a) (reg2 ,b))
                     (addq reg1 reg2)))
    '(,any  #f))
)
|#

(define-macro (match val . cases)
  (match-expr val cases))

(let ()
  (define (t1 d)
    (write (list 't1 d))(display " => ")
    (match d
      (`(1 2 3)   (write (list :matched!)))
      (`(1 ,a 3)  (write (list :matched! :a a)))
      (`(1 ,a ,c) (write (list :matched! :a a :c c)))
      )
    (newline)
    )
  (t1 '())
  (t1 '(1))
  (t1 '(1 2))
  (t1 '(1 2 3))
  (t1 '(1 x 3))
  (t1 '(1 x y))
  (define (t2 d)
    (write (list 't2 d))(display " => ")
    (match d 
      (`(1 (2 3) 4)     (write (list :matched!)))
      (`(1 (2 ,bb) 5)   (write (list :matched! :bb bb)))
      (`(1 (2 3) ,c)    (write (list :matched! :c c)))
      (`(1 ,b ,c)       (write (list :matched! :b b :c c)))
      (`(2 ,@r)         (write (list :matched! :r r)))
      )
    (newline)
    )
  (t2 '())
  (t2 '(1))
  (t2 '(1 2 4))
  (t2 '(1 (2 3) 4))
  (t2 '(1 (2 3) 5))
  (t2 '(1 (2 3) 6))
  (t2 '(1 (2 3) "foo"))
  (t2 '(1 (4 3) 4))
  (t2 '(2 3 4 5))
)
#|
|#
