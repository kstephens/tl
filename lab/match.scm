(define (match-expr val cases)
  (define (match-cases val cases f)
    (let ((val-name (gensym 'match-val)))
      `(let ((,val-name ,val))
         ,(match-cases-list val-name cases f))))
  (define (match-cases-list val cases f)
    (if (null? cases) f
      `(match-case val (car cases)
         (match-cases-list val (cdr cases) f))))
  (define (match-case val case f)
    (match-datum (car case) val `(begin ,@(cdr case)) f))
  (define (match-datum pat val t f)
    (if (quasiquote? pat)
      (match-sequence (cadr pat) val t f)
      (match-item pat val t f)))
  (define (match-sequence pat val t f)
    (if (null? pat) (match-item pat val t f)
      (if (and (pair? pat) (unquote-splicing? (car pat)))
        (match-var (cadr (car pat)) val t f)
        (let ( (car-val (gensym 'car-))
               (cdr-val (gensym 'cdr-)))
          `(and
             (pair? ,val)
             (let ( (,car-val (car ,val))
                    (,cdr-val (cdr ,val))
                    )
               ,(match-item (car pat) car-val
                  (match-sequence (cdr pat) cdr-val t f) f)))))))
  (define (match-item pat val t f)
    (cond
      ((unquote? pat) (match-var      (cadr pat)   val t f))
      ((pair? pat)    (match-sequence pat          val t f))
      (else           (match-atom     (quote! pat) val t f))))
  (define (match-var var val t f)
    `(let ((,var ,val))
       ,t))
  (define (match-atom pat val t f)
    (if (and (eq? t #t) (eq? f #f))
      `(equal? ,pat ,val)
      `(if (equal? ,pat ,val)
         ,t ,f)))
  (define (quote! x)
    (list 'quote x))
  (define (unquote? pat)
    (and 
      (pair? pat)
      (eq? 'unquote (car pat))
      (pair? (cdr pat))
      (symbol? (cadr pat))))
  (define (unquote-splicing? pat)
      (and 
        (pair? pat)
        (eq? 'unquote-splicing (car pat))
        (pair? (cdr pat))
        (symbol? (cadr pat))))
  (define (quasiquote? pat)
    (and 
      (pair? pat)
      (eq? 'quasiquote (car pat))))

  (define (test f pat)
    (newline)
    (write (list 'match pat 'val))(newline)
    (display " => ")(newline)
    (write (f pat 'val '(:matched! :a a) :NOT-matched!))(newline))
    
  (test match-datum 'a)
  (test match-datum ',a)
  (test match-datum '())
  (test match-datum '(1))
  
  (test match-datum '`())
  (test match-datum '`())
  (test match-datum '`(1))
  
  (test match-datum '`(,a))
  (test match-datum '`(,@rest))
  (test match-datum '`(1 ,@rest))
  (test match-datum '`(1 a 3))
  (test match-datum '`(1 ,a 3))

  (match-cases val cases #t)
)
(let ()
  (define (test val . cases)
    (newline)
    (write `(match-expr ,val ,@cases))(newline)
    (display " => ")(newline)
    (write (match-expr val cases)(newline))
  )
  (test 'x
    '(`(fx+ ,a ,b) `(let ((reg1 ,a) (reg2 ,b))
                     (addq reg1 reg2)))
    '(,any  #f))
)

(define-macro (match val . cases)
  (match-expr val cases))
